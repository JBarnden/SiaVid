import json, sys
from os import getcwd
from threading import Thread
from time import sleep

from flask import Flask, request, make_response, redirect

from pipeline import Pipeline, Timeline
from exampleplugins import VSSChunkMiner, TrieMiner, TrieSearch, ReadFileAcquirer, YoutubeSRTAcquirer, FileToLineMiner

app = Flask(__name__, static_url_path='', static_folder=getcwd() + '/Frontend-Web')

# TODO: Some kind of binding of 'url' setting to source IP. Or passing during search possibly?

pl = Pipeline()
timelines = {}

# initial URL - changed by /setURL
url = "https://www.youtube.com/watch?v=wGkvyN6s9cY"

# Register route handlers for URLs...
@app.route("/")
def root():
    return redirect('/index.html')

@app.route("/setURL", methods=['POST'])
def setURL():
    global url
    url = request.form['uri']
    url = url.encode("ascii")
    resp = make_response(json.dumps("URL updated"))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/getTimelines/")
def getSearch():
    result = {}

    for name in timelines:
        result[name] = timelines[name].prettyName

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/status/<timeline>")
def checkReady(timeline):
    status = None # default sentinel value
    
    statuses = ["READY", "PENDING", "ERROR", "OUT_OF_DATE"]

    if timeline in timelines:

        # get the name of the last miner on the timeline
        miner = timelines[timeline].miner
        if type(miner) == list:
            miner = miner[-1]
        
        # pull its status
        status = pl.mine[miner].checkStatus()

    # return the status
    resp = make_response(json.dumps(statuses[status]))
    resp.headers['Access-Control-Allow-Origin'] = '*'

    return resp

@app.route("/search/<timeline>", methods=['POST'])
def doSearch(timeline):

    convertedResults = None

    if timeline in timelines:

        # get the name of the last miner on the timeline
        miner = timelines[timeline].miner
        if type(miner) == list:
            miner = miner[-1]
        
        # pull its status
        status = pl.mine[miner].checkStatus()
        if status == 0:

            search = timelines[timeline].search
            corpus = timelines[timeline].corpus[-1]

            terms = request.form['searchterms'] # TODO: Sanitising of search terms
            terms = terms.encode("ascii").lower()
            terms = terms.split(" ")

            results = pl.performSearch(corpus, search, terms)

            # Convert to serialisable format...
            convertedResults = []
            for result in results:
                curr = {}
                curr['start'] = result.startTime
                curr['end'] = result.endTime
                convertedResults.append(curr)

    resp = make_response(json.dumps(convertedResults))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/add/<timeline>", methods=['GET'])
def doAcquire(timeline):
    """ Trigger acquisition and processing for a new timeline """

    result = None

    if timeline in timelines:
        global url
        result = timeline

        t = Thread(target=pl.generateTimeline, name = timeline + ":", args=(timelines[timeline], url))
        t.start()

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

# Initial setup stuff...

if __name__ == "__main__":

    print ""

    # add our various pipeline components here
    pl.addAcquirer(YoutubeSRTAcquirer(), 'ytsub') # downloads an autogenerated VSS file from Youtube to temp folder
    pl.addMiner(FileToLineMiner(), 'fileline') # processes a file into a list of lines
    pl.addMiner(VSSChunkMiner(), 'vssminer') # processes a list of lines in VSS format into a list of SRTChunks
    pl.addMiner(TrieMiner(), 'trieminer') # Processes list of SRTChunks into a trie
    pl.addMiner(TrieMiner(), 'trieminer2') # Processes list of SRTChunks into a trie
    pl.addSearch(TrieSearch(), 'triesearch') # searches a trie

    print ""

    # we pre-specify the timelines we want to offer...

    timelines['subtitles'] = Timeline(
        "Downloaded Subtitles",                 # prettyName
        'ytsub',                                # acquireTag
        ['fileline', 'vssminer', 'trieminer'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    timelines['subtitles2'] = Timeline(
        "Downloaded Subtitles 2",                 # prettyName
        'ytsub',                                # acquireTag
        ['fileline', 'vssminer', 'trieminer2'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer2'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    # timelines['speechrec'] = Timeline(
    #     "Speech Recognition",
    #     'ytaudiochunker',
    #     ['speechrec', 'trieminer'],
    #     ['speechrec', 'trieminer'],
    #     'triesearch'
    # )

    # timelines['someother'] = Timeline(
    #     "Some Other Timeline",
    #     'ytaudiochunker',
    #     ['speechrec', 'trieminer'],
    #     ['speechrec', 'trieminer'],
    #     'triesearch'
    # )


    app.run(host='0.0.0.0', use_reloader=True, threaded=True)

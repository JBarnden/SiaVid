import json, sys
import os
from threading import Thread
from time import sleep

from flask import Flask, request, make_response, redirect

from pipeline import Pipeline, Timeline, statuses, READY, WAIT, OUT_OF_DATE, ERROR
from exampleplugins import VSSChunkMiner, TrieMiner, TrieSearch, ReadFileAcquirer, AlwaysFailAcquirer, YoutubeAutoVSSAcquirer, FileToLineMiner

app = Flask(__name__, static_url_path='', static_folder=os.getcwd() + '/Frontend-Web')

pl = Pipeline()
timelines = {}

# initial URL - changed by /setURL
url = "https://www.youtube.com/watch?v=wGkvyN6s9cY"

# Register route handlers for URLs...
@app.route("/")
def root():
    return redirect('/index.html')

@app.route("/setURL", methods=['POST'])
def setURL():
    """ Saves current data, updates the internal video URL and clears
        stored data
    """

    global url

    id = url.split("=")[1] # get youtube ID.

    for timeline in timelines:
        print "Saving timeline {}".format(timeline)
        pl.saveCorpus(timelines[timeline].corpus[-1], id)

    url = request.form['uri']
    url = url.encode("ascii")

    pl.clearMemory()

    resp = make_response(json.dumps("URL updated"))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/getTimelines/")
def getSearch():
    """ Returns a list of available timelines and their prettynames
    """

    result = {}

    for name in timelines:
        result[name] = timelines[name].prettyName

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/status/<timeline>")
def checkReady(timeline):
    """ Returns a given timeline's status
    """

    status = None # default sentinel value
    
    if timeline in timelines:
        status = timelines[timeline].status

    # return the status
    resp = make_response(json.dumps(statuses[status]))
    resp.headers['Access-Control-Allow-Origin'] = '*'

    return resp

@app.route("/search/<timeline>", methods=['POST'])
def doSearch(timeline):
    """ Performs a search on a given timeline
    """

    convertedResults = None # Sentinel value

    if timeline in timelines:

        if timelines[timeline].status == READY:

            search = timelines[timeline].search
            corpus = timelines[timeline].corpus[-1]

            terms = request.form['searchterms'] # TODO: Sanitising of search terms
            terms = terms.encode("ascii").lower()
            terms = terms.split(" ")

            results = pl.performSearch(corpus, search, terms)

            # Convert to serialisable format...
            if len(results) > 0:
                convertedResults = []

            for result in results:
                curr = {}
                curr['start'] = result.startTime
                curr['end'] = result.endTime
                convertedResults.append(curr)

    resp = make_response(json.dumps(convertedResults))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/add/<timeline>", methods=['GET'])
def doAcquire(timeline):
    """ Trigger acquisition and processing for a new timeline """

    result = None

    if timeline in timelines:
        global url
        id = url.split("=")[1]

        result = timeline

        if pl.loadCorpus(timelines[timeline].corpus[-1], id):
            print "Timeline is ready."
            timelines[timeline].status = READY
        else:
            regenerate(timeline)

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/regen/<timeline>", methods=['GET'])
def regen(timeline):
    result = None

    if timeline in timelines:
        result = timeline
        regenerate(timeline)

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp   

def regenerate(timeline):
    """ Forcibly regenerate a given timeline """

    t = Thread(target=pl.generateTimeline, name = timeline, args=(timelines[timeline], url))
    t.start()

# Initial setup...

if __name__ == "__main__":

    print ""

    # add our various pipeline components here
    pl.addAcquirer(AlwaysFailAcquirer(), 'fail')
    pl.addAcquirer(YoutubeAutoVSSAcquirer(), 'ytsub') # downloads an autogenerated VSS file from Youtube to temp folder
    pl.addMiner(FileToLineMiner(), 'fileline') # processes a file into a list of lines
    pl.addMiner(VSSChunkMiner(), 'vssminer') # processes a list of lines in VSS format into a list of SRTChunks
    pl.addMiner(VSSChunkMiner(), 'vssminer2') # processes a list of lines in VSS format into a list of SRTChunks
    pl.addMiner(TrieMiner(), 'trieminer') # Processes list of SRTChunks into a trie
    pl.addMiner(TrieMiner(), 'trieminer2') # Processes list of SRTChunks into a trie
    pl.addMiner(TrieMiner(), 'trieminer3') # Processes list of SRTChunks into a trie
    pl.addSearch(TrieSearch(), 'triesearch') # searches a trie

    print ""

    # we pre-specify the timelines we want to offer...

    timelines['subtitles'] = Timeline(
        "Auto Subtitles",                 # prettyName
        ['fail', 'ytsub'],                                # acquireTag
        ['fileline', 'vssminer', 'trieminer'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    timelines['subtitles2'] = Timeline(
        "Duplicate auto subs",                 # prettyName
        'ytsub',                                # acquireTag
        ['fileline', 'vssminer', 'trieminer'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    timelines['fail'] = Timeline(
        "This timeline always fails to acquire", # prettyName
        'fail',                                # acquireTag
        ['fileline', 'vssminer', 'trieminer2'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer2'],  # corpusTags in order
        'triesearch'                            # searchTag
    )
    timelines['alttrieminer'] = Timeline(
        "Secondary Trieminer",                 # prettyName
        'ytsub',                                # acquireTag
        ['fileline', 'vssminer2', 'trieminer2'],  # minerTags in order
        ['fileline', 'vssminer2', 'trieminer2'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    # t1 = Thread(target=pl.generateTimeline, name = "t1", args=(timelines['subtitles'], url))
    # t1.start()

    # t1.join()
    # id = url.split("=")[1]

    # pl.saveCorpus(timelines['subtitles'].corpus[-1], id)

    # t2 = Thread(target=pl.generateTimeline, name = "t2", args=(timelines['subtitles2'], url))
    # t2.start()
    # sleep(5)
    # pl.resetTimeline(timelines['subtitles'])
    
    # t3 = Thread(target=pl.generateTimeline, name = "t3", args=(timelines['subtitles3'], url))
    # t3.start()

    # t4 = Thread(target=pl.generateTimeline, name = "t4", args=(timelines['subtitles4'], url))
    # t4.start()

    # timelines['speechrec'] = Timeline(
    #     "Speech Recognition",
    #     'ytaudiochunker',
    #     ['speechrec', 'trieminer'],
    #     ['speechrec', 'trieminer'],
    #     'triesearch'
    # )

    # timelines['someother'] = Timeline(
    #     "Some Other Timeline",
    #     'ytaudiochunker',
    #     ['speechrec', 'trieminer'],
    #     ['speechrec', 'trieminer'],
    #     'triesearch'
    # )


    app.run(host='0.0.0.0', use_reloader=True, threaded=True)

import json, sys
from os import getcwd
from threading import Thread
from time import sleep

from flask import Flask, request, make_response, redirect

from pipeline import Pipeline, Timeline, statuses
from exampleplugins import VSSChunkMiner, TrieMiner, TrieSearch, ReadFileAcquirer, AlwaysFailAcquirer, YoutubeSRTAcquirer, FileToLineMiner

app = Flask(__name__, static_url_path='', static_folder=getcwd() + '/Frontend-Web')

# TODO: Some kind of binding of 'url' setting to source IP. Or passing during search possibly?

pl = Pipeline()
timelines = {}

# initial URL - changed by /setURL
url = "https://www.youtube.com/watch?v=wGkvyN6s9cY"

# Register route handlers for URLs...
@app.route("/")
def root():
    return redirect('/index.html')

@app.route("/setURL", methods=['POST'])
def setURL():
    global url
    url = request.form['uri']
    url = url.encode("ascii")

    # TODO: Add saving/removing of existing data and loading of any archived data

    resp = make_response(json.dumps("URL updated"))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/getTimelines/")
def getSearch():
    result = {}

    for name in timelines:
        result[name] = timelines[name].prettyName

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/status/<timeline>")
def checkReady(timeline):
    status = None # default sentinel value
    
    if timeline in timelines:
        status = timelines[timeline].status

    # return the status
    resp = make_response(json.dumps(statuses[status]))
    resp.headers['Access-Control-Allow-Origin'] = '*'

    return resp

@app.route("/search/<timeline>", methods=['POST'])
def doSearch(timeline):

    convertedResults = None

    if timeline in timelines:

        # get the name of the last miner on the timeline
        miner = timelines[timeline].miner
        if type(miner) == list:
            miner = miner[-1]
        
        # pull its status
        status = pl.mine[miner].checkStatus()
        if status == 0:

            search = timelines[timeline].search
            corpus = timelines[timeline].corpus[-1]

            terms = request.form['searchterms'] # TODO: Sanitising of search terms
            terms = terms.encode("ascii").lower()
            terms = terms.split(" ")

            results = pl.performSearch(corpus, search, terms)

            # Convert to serialisable format...
            convertedResults = []
            for result in results:
                curr = {}
                curr['start'] = result.startTime
                curr['end'] = result.endTime
                convertedResults.append(curr)

    resp = make_response(json.dumps(convertedResults))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route("/add/<timeline>", methods=['GET'])
def doAcquire(timeline):
    """ Trigger acquisition and processing for a new timeline """

    result = None

    if timeline in timelines:
        global url
        result = timeline

        t = Thread(target=pl.generateTimeline, name = timeline, args=(timelines[timeline], url))
        t.start()

    resp = make_response(json.dumps(result))
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

# Initial setup stuff...

if __name__ == "__main__":

    print ""

    # add our various pipeline components here
    pl.addAcquirer(AlwaysFailAcquirer(), 'fail')
    pl.addAcquirer(YoutubeSRTAcquirer(), 'ytsub') # downloads an autogenerated VSS file from Youtube to temp folder
    pl.addMiner(FileToLineMiner(), 'fileline') # processes a file into a list of lines
    pl.addMiner(VSSChunkMiner(), 'vssminer') # processes a list of lines in VSS format into a list of SRTChunks
    pl.addMiner(VSSChunkMiner(), 'vssminer2') # processes a list of lines in VSS format into a list of SRTChunks
    pl.addMiner(TrieMiner(), 'trieminer') # Processes list of SRTChunks into a trie
    pl.addMiner(TrieMiner(), 'trieminer2') # Processes list of SRTChunks into a trie
    pl.addMiner(TrieMiner(), 'trieminer3') # Processes list of SRTChunks into a trie
    pl.addSearch(TrieSearch(), 'triesearch') # searches a trie

    print ""

    # we pre-specify the timelines we want to offer...

    timelines['subtitles'] = Timeline(
        "Downloaded Subtitles",                 # prettyName
        ['fail', 'ytsub'],                                # acquireTag
        ['fileline', 'vssminer', 'trieminer'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    timelines['subtitles2'] = Timeline(
        "Downloaded Subtitles 2",                 # prettyName
        'fail',                                # acquireTag
        ['fileline', 'vssminer', 'trieminer2'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer2'],  # corpusTags in order
        'triesearch'                            # searchTag
    )
    timelines['subtitles3'] = Timeline(
        "Downloaded Subtitles 3",                 # prettyName
        'ytsub',                                # acquireTag
        ['fileline', 'vssminer2', 'trieminer2'],  # minerTags in order
        ['fileline', 'vssminer2', 'trieminer2'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    timelines['subtitles4'] = Timeline(
        "Downloaded Subtitles 4",                 # prettyName
        'ytsub',                                # acquireTag
        ['fileline', 'vssminer', 'trieminer3'],  # minerTags in order
        ['fileline', 'vssminer', 'trieminer3'],  # corpusTags in order
        'triesearch'                            # searchTag
    )

    # t1 = Thread(target=pl.generateTimeline, name = "t1", args=(timelines['subtitles'], url))
    # t1.start()
    # t2 = Thread(target=pl.generateTimeline, name = "t2", args=(timelines['subtitles2'], url))
    # t2.start()
    # sleep(5)
    # pl.resetTimeline(timelines['subtitles'])
    
    # t3 = Thread(target=pl.generateTimeline, name = "t3", args=(timelines['subtitles3'], url))
    # t3.start()

    # t4 = Thread(target=pl.generateTimeline, name = "t4", args=(timelines['subtitles4'], url))
    # t4.start()

    # timelines['speechrec'] = Timeline(
    #     "Speech Recognition",
    #     'ytaudiochunker',
    #     ['speechrec', 'trieminer'],
    #     ['speechrec', 'trieminer'],
    #     'triesearch'
    # )

    # timelines['someother'] = Timeline(
    #     "Some Other Timeline",
    #     'ytaudiochunker',
    #     ['speechrec', 'trieminer'],
    #     ['speechrec', 'trieminer'],
    #     'triesearch'
    # )


    app.run(host='0.0.0.0', use_reloader=True, threaded=True)
